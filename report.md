# 计网第二次大作业(Router)实验报告

姓名：郑舒文
学号：2018013426

## 基本思路

在这里自顶向下的分析本次大作业的基本思路。

**`handlePakcet`函数**：当路由器收到链路层数据包(frame)时，会调用函数`handlePacket`函数。收到的frame可分为两类：arp数据包和ip数据包，根据该分类，分别去调用`handleArpPacket`函数和`handleIpPacket`函数。

* **`handleArpPacket`函数**： arp数据包又可以分为两类：arp request和arp reply

  * 如果是arp request，路由器检测其ip地址是否指向自己，是则发送回一个对应的arp reply，否则忽略
  * 如果是arp reply，路由器将frame中ip地址和mac地址的映射存储进`arp cache`数据结构，并查找`arp request`中对应的request请求，将跟这个请求相关联的所有待发数据包全部转发出去，最后删除这个请求

* **`handleIpPacket`函数**：ip数据包可以分为两类：icmp数据包和普通ip数据包，注意这里的“icmp数据包”是狭义的，仅指代那些目的ip地址指向路由器的icmp数据包，对于那些目的ip地址不是路由器的icmp数据包，路由器将它们视若不见地转发出去即可；相应地，“普通ip数据包”就是一个广义的概念了。

  因此路由器检测该数据包的目的地址是否指向自己，

  * 如果是指向自己，路由器需要发送一个对应的icmp echo reply

  * 如果不是指向自己，路由器需要执行正常的转发流程：

    * 查找路由表(routing table)，找到转发出口

    * 查找`arp cache`数据结构，寻找下一跳的mac地址：若找到，则将ip头内的`ttl`减1，重新计算校验和，立即转发；若未找到，则在`arp request`数据结构中新建一个request元素，或为原有某个对应的request元素添加一个待发的数据包，等待未来arp reply的到来

**`periodicCheckArpRequestsAndCacheEntries`函数**：该函数在`ticker`函数中每秒被调用一次，内部检查`arp cache`和`arp request`数据结构元素。

* 对`arp cache`数据结构，移除那些过时（超过30s）的表项。
* 对`arp request`数据结构：
  * 如果某个request表项已经重复发送5次，说明目标主机或端口不可达（包括目的ip地址不存在的情况），需要给与这个request相关联的每个packet发送源发送icmp错误诊断数据包，并且移除这个request表项
  * 如果这个request发送次数 < 5，则继续重发

**`RoutingTableEntry RoutingTable::lookup(uint32_t ip) const`函数**：该函数执行最长前缀匹配算法，实现查找路由表逻辑。

## 遇到的难题

### 涉及的问题非常综合

总体来看，路由器涉及链路层、网络层两个层次；其次，为实现端到端数据传输，路由器需要实现arp协议和ip协议；再次，为实现`ping`指令和`traceroute`指令，路由器需要实现icmp协议。在面对实际问题的时候，以上领域错综交织，于是处理逻辑也变得复杂，需要保持清醒，厘清思路，整理出如上所述流程再开始写代码。

### 具体技术难题：arp数据包内，以太帧头mac地址是否等于arp头mac地址

答案是肯定的，因为arp数据包的沟通只可能发生在相邻两个结点之间。想象现在顺序地有A B C三个结点，假设A向C发arp数据包，它必须要弄清B的mac地址，因此还是首先会向B发送arp请求，因此arp的交流最终发生在相邻两个结点之间。

### 具体技术难题：路由器回复还是转发的判断依据

arp数据包，只可能被回复而不可能被转发；普通ip数据包，路由器将会直接转发；对于icmp数据包，路由器既有可能转发也有可能回复。

由此，判断路由器接下来执行回复还是转发，并不能单单依靠数据包类型，而应该依赖对该包目的地址是否指向路由器的判断。因此，在`handleArpPacket`函数内，如果arp request数据包的目的ip地址不是路由器，则路由器直接忽略该包；在`handleIpPacket`函数内，指向路由器的数据包需要给予回复（此时该包只可能是icmp echo request类型），不指向路由器的数据包直接转发即可。

这里还有一个值得注意的小问题是，在`handleIpPacket`函数内如何判断一个数据包的目的指向路由器？并不是简单地判断该包的目的ip地址等于入口的ip地址，而是是否是所有网卡接口的ip地址，即路由器需要回复它所有接口的icmp请求。而在`handleArpPacket`函数内，由于arp数据包的沟通只可能发生在相邻两个结点之间，因此如果arp数据包发送给路由器某个接口，那么它一定也指向了路由器的这个接口（它不可能指向其他接口了）。

### 具体技术难题：路由器对数据包`ttl`的判定

`ttl`(time to life)指代了一个数据包接下来还能经历的跳数。当一个数据包的`ttl > 0`时，它拥有被沿途主机或路由器解析的权限；当`ttl <= 0`时，该包到达存活寿命、应被丢弃。

在本次作业中，判断一个数据包是否丢弃，光靠判断`ttl <= 0`是不够的，比如一个要被转发出去的普通ip数据包，当其`ttl = 1`时，路由器也不应该转发之，而是直接丢弃。因此总结起来，在`handleIpPacket`函数内，首先判断`ttl <= 0`；当这个包的目的地址指向路由器以外的领域时，再判断`ttl = 1`。

### 具体技术难题：如何判断源主机在向一个不存在的ip地址发送`ping`指令，以及如何给源主机返回错误信息

路由器无法直接判断这个目的ip地址是否存在，比如当源主机向路由器连接的某个子网内部发送`ping`指令，ping指令的数据包将在子网内部石沉大海，路由器如何获知这个消息？可以另辟蹊径：icmp数据包本身滞留在`arp request`数据结构的某个request元素中，当这个request被重复发送5次时，我们就可以认为icmp数据包已经消亡，并且消亡的原因只可能是目的ip地址不存在（虽然有可能出于网络原因超时、丢包，但在本次作业环境中这几乎不可能）。

返回错误信息时，有一个小trick。`arp request`数据结构中，每个`PendingPacket`元素的`iface`指代该包正常转发情况下的出口，而返回错误信息时，需要使得icmp错误信息从它进入路由器的入口原路返回，因此需要从数据包本身的以太帧头部获取目的mac地址信息，进入找到当初的入口。因此，数据包放进等待队列时不能急于为了转发修改信息，而要等到真正出队列、被转发的那一刻。

### 其他难题：调试困难

本次作业只能输出调试，比较麻烦。在调试过程中，发现`arp-cache.cpp`文件的函数中使用`std::cerr`时，vscode语法报错“`cerr`不是`std`的成员”，上网搜索未能解决。

## 实验体会

这次实验锻炼了我的代码能力和调试能力，加深了我对路由器的理解，对路由器、交换机、集线器三者概念的区分。非常显然的理论，实现起来却是细节繁杂、困难多多，可以预见，一个有创意的理论被实现成协议并被广泛使用是多么困难的一件事！

本次作业我和杨旭冉同学讨论了路由器的基本思路，在此提出感谢！同时也非常感谢夏金城、陈衍德两位同学的帮助以及助教老师的热心解答！